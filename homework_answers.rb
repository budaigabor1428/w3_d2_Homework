MVP Questions
In our Property Tracker application:

Q1. Where are we instantiating instances of the Property class?

In the console.rb file, with the .new commands.

Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?

In the save function, right after the "sql =" part.

Q3. In console.rb, which lines modify the database?

Property.delete_all()
property1 = Property.new
property2 = Property.new
property3 = Property.new
property1.delete()

Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?

It is the SQL's responsibility to generate the id.

Q5. Where and how do we assign the property id (that is generated by the database) to the ruby object?

In the initializing section, with the id property.

Q6. Why do we put a guard (an ‘if’ clause) on the @id attribute in the constructor?

This way it initializes the id only if it already exists.

Q7. Why are some of the CRUD actions represented by instance methods, and others, class methods?

Because sometimes we want to execute a command just on one instance(instance method, e.g. delete) but sometimes we want the method to go through the whole class (class method, e.g. find).

Q8. What type of data structure is returned by db.exec() and db.exec_prepared(), and how do we index into it to pull out a desired attribute?

They return an array of hashes. We can map through them and then use the index position of the desired element.

Q9. Why do we use prepared statements when performing database operations?

We are communicating with the SQL file so we have to use that syntax.

Extension Questions
Look at the find_by_id and find_by_address methods in the Property class.

Q10. What do they take in as their arguments?

The elements of the database.

Q11. What are their return values?

Class
